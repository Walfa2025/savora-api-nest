import { Body, Controller, Get, Param, Patch, Post, Query, Req } from '@nestjs/common';
import { Request } from "express";

import { JwtAuthGuard } from "./auth/jwt-auth.guard";
import { PrismaService } from './prisma/prisma.service';


type AuthedReq = Request & { user?: { id: string; role?: string } };

function claimCode6() {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

const ALLOWED_STATUSES = new Set(['RESERVED', 'PAID', 'CANCELLED', 'CLAIMED', 'EXPIRED', 'NO_SHOW']);

@Controller()
export class OrdersController {
  constructor(private readonly prisma: PrismaService) {}


  @Get('/vendor/customers/blocked')
  async blockedCustomers(@Query() q: { vendorId?: string; minStrikes?: string; take?: string }) {
    const vendorId = (q?.vendorId || '').trim() || null;
    const minStrikes = Math.max(1, parseInt((q?.minStrikes || '3'), 10) || 3);
    const take = Math.min(200, Math.max(1, parseInt((q?.take || '50'), 10) || 50));

    // Alleen NO_SHOW strikes tellen (policy)
    const strikesRows = await this.prisma.strike.findMany({
      where: { reason: 'NO_SHOW', isActive: true },
      select: { userId: true },
    });

    const counts: Record<string, number> = {};
    for (const r of strikesRows) counts[r.userId] = (counts[r.userId] || 0) + 1;

    let blockedUserIds = Object.keys(counts).filter((uid) => counts[uid] >= minStrikes);
    if (blockedUserIds.length === 0) return { items: [], meta: { vendorId, minStrikes, take } };

    // Optioneel: filter op vendor (alleen klanten die ooit bij die vendor besteld hebben)
    if (vendorId) {
      const cust = await this.prisma.order.findMany({
        where: { customerUserId: { in: blockedUserIds }, offer: { vendorId } },
        select: { customerUserId: true },
        distinct: ['customerUserId'],
      });
      blockedUserIds = cust.map((x) => x.customerUserId);
      if (blockedUserIds.length === 0) return { items: [], meta: { vendorId, minStrikes, take } };
    }

    const users = await this.prisma.user.findMany({
      where: { id: { in: blockedUserIds } },
      select: { id: true, phoneE164: true, name: true, role: true, createdAt: true, updatedAt: true },
      take,
    });

    const userIds = users.map((u) => u.id);

    const lastOrders = await this.prisma.order.findMany({
      where: {
        customerUserId: { in: userIds },
        ...(vendorId ? { offer: { vendorId } } : {}),
      },
      orderBy: { createdAt: 'desc' },
      distinct: ['customerUserId'],
      include: { offer: { include: { vendor: true } } },
      take,
    });

    const lastByCustomer = new Map(lastOrders.map((o) => [o.customerUserId, o]));

    const items = users
      .map((u) => ({
        customer: u,
        strikes: counts[u.id] || 0,
        lastOrder: lastByCustomer.get(u.id) || null,
      }))
      .sort((a, b) => b.strikes - a.strikes);

    return { items, meta: { vendorId, minStrikes, take } };
  }
  @Post('/orders')
  async reserve(@Req() req: AuthedReq, () body: { offerId: string; customerPhone?: string; customerName?: string }) {
    const offerId = (body?.offerId || '').trim();
    if (!offerId) return { ok: false, error: 'offerId_required' };

    let customerId = (req?.user?.id || '').toString().trim();

    // MVP fallback: identify customer by phone/name when no JWT is present
    if (!customerId) {
      const phone = (body?.customerPhone || '+355690000001').trim();
      const name = (body?.customerName || 'Demo Customer').trim();

      const customer = await this.prisma.user.upsert({
        where: { phoneE164: phone },
        update: { name },
        create: { phoneE164: phone, name, role: 'CUSTOMER' },
      });

      customerId = customer.id;
    }

    const now = new Date();
    const reservedUntil = new Date(now.getTime() + 10 * 60 * 1000);



    return this.prisma.$transaction(async (tx) => {
      const strikes = await tx.strike.count({
        where: { userId: customerId, reason: 'NO_SHOW', isActive: true },
      });
      if (strikes >= 3) return { ok: false as const, error: 'blocked_strikes', strikes };

      const updated = await tx.offer.updateMany({
        where: { id: offerId, status: 'LIVE', qtyAvailable: { gt: 0 } },
        data: { qtyAvailable: { decrement: 1 } },
      });

      if (updated.count !== 1) return { ok: false as const, error: 'sold_out_or_not_live' };

      for (let i = 0; i < 5; i++) {
        const code = claimCode6();
        try {
          const order = await tx.order.create({
            data: {
              offerId,
              customerUserId: customerId,
              status: 'RESERVED',
              reservedUntil,
              claimCode: code,
            },
            include: { offer: true },
          });
          return { ok: true as const, order };
        } catch (e: any) {
          if (e?.code === 'P2002') continue;
          throw e;
        }
      }

      throw new Error('claim_code_generation_failed');
    });
  }


  @Patch('/orders/:id/cancel')
  async cancel(@Param('id') id: string) {
    const orderId = (id || '').trim();
    if (!orderId) return { ok: false, error: 'order_id_required' };

    return this.prisma.$transaction(async (tx) => {
      const order = await tx.order.findUnique({ where: { id: orderId } });
      if (!order) return { ok: false as const, error: 'not_found' };

      if (order.status !== 'RESERVED' && order.status !== 'PAID') {
        return { ok: false as const, error: 'not_cancellable', status: order.status };
      }

      const updatedOrder = await tx.order.update({
        where: { id: orderId },
        data: { status: 'CANCELLED' },
      });

      await tx.offer.update({
        where: { id: order.offerId },
        data: { qtyAvailable: { increment: 1 } },
      });

      return { ok: true as const, order: updatedOrder };
    });
  }

  @Post('/vendor/orders/:id/claim')
  async claim(@Param('id') id: string, @Body() body: { claimCode: string }) {
    const orderId = (id || '').trim();
    const claimCode = (body?.claimCode || '').trim();
    if (!orderId) return { ok: false, error: 'order_id_required' };
    if (!claimCode) return { ok: false, error: 'claim_code_required' };

    const order = await this.prisma.order.findUnique({ where: { id: orderId } });
    if (!order) return { ok: false, error: 'not_found' };

    if (order.status !== 'PAID') {
      return { ok: false, error: 'not_paid', status: order.status };
    }

    if (order.claimCode !== claimCode) {
      return { ok: false, error: 'claim_code_mismatch' };
    }

    const updated = await this.prisma.order.update({
      where: { id: orderId },
      data: { status: 'CLAIMED' },
    });

    return { ok: true, order: updated };
  }

  // Vendor dashboard list
  @Get('/vendor/orders')
  async vendorOrders(
    @Query('vendorId') vendorId?: string,
    @Query('status') status?: string,
    @Query('take') take?: string,
  ) {
    const where: any = {};

    if (vendorId && vendorId.trim()) {
      where.offer = { vendorId: vendorId.trim() };
    }

    if (status && ALLOWED_STATUSES.has(status)) {
      where.status = status;
    }

    const nRaw = parseInt((take || '50').trim(), 10);
    const n = Number.isFinite(nRaw) ? Math.max(1, Math.min(200, nRaw)) : 50;

    const items = await this.prisma.order.findMany({
      where,
      orderBy: { createdAt: 'desc' },
      take: n,
      include: {
        offer: { include: { vendor: true } },
        customer: true,
      },
    });

    return { items, meta: { vendorId: vendorId || null, status: status || null, take: n } };
  }
}
